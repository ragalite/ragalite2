package ragalite.uio;

import java.io.Writer;
import java.io.PrintStream;
import java.util.function.Consumer;
import java.util.List;
import java.util.LinkedList;

/**
 * One-to-many relay for writing character streams.
 *
 * In particular, this class supports relaying to 
 * {@link java.io.PrintStream PrintStreams}
 * (System.out and System.err included) and 
 * {@link java.util.function.Consumer String Consumers} (for custom callbacks).
 *
 * The order of receivers in which a character stream is relayed to is
 * undefined.
 *
 * A stream or callback may be attached to a relay multiple times and thus be
 * relayed a message however many times it was added.
 * 
 */
public final class WriterRelay extends Writer {

	/* Generated by default.
	public TeeWriter() {
		super();
	}
	*/
	private final List<Consumer<String>> receivingCallbacks;
	private final List<PrintStream> receivingStreams;

	// TODO: Consider dependency injection for the container implementation.

	/**
	 * {@inheritDoc}
	 *
	 * After construction, this relay will immediately be able to add 
	 * (and otherwise manipulate its) receivers.
	 *
	 */
	public WriterRelay() {
		receivingCallbacks = new LinkedList<>();
		receivingStreams = new LinkedList<>();
	}
	
	/**
	 * Adds a receiving stream to this relay. 
	 *
	 * After its addition, any message sent to this relay will be sent to
	 * the stream as well.
	 *
	 * @param receivingStream Stream to relay messages to
	 *
	 */
	public void addReceiver(final PrintStream receivingStream) {
		receivingStreams.add(receivingStream); // Decorator
	}

	/**
	 * Adds a callback to this relay. 
	 *
	 * After its addition, any message sent to this relay will be sent as
	 * a parameter to the callback.
	 *
	 * @param receivingStream Callback to relay messages to
	 *
	 */
	public void addReceiver(final Consumer<String> receivingCallback) {
		receivingCallbacks.add(receivingCallback); // Decorator
	}

	/**
	 * Relays a message to each receiver.
	 *
	 * @param message Message to send to each receiver
	 *
	 */
	public void relay(final String message) {
		// Relay to callbacks...
		for (Consumer<String> callback : receivingCallbacks) {
			callback.accept(message);
		}
		// ... then streams. (Order's arbitrary, actually.)
		for (PrintStream stream : receivingStreams) {
			stream.print(message);
		}
	}

	/**
	 * Relays a portion of an array of characters.
	 *
	 * @param cbuf Array to relay characters from
	 * @param off  Offset from which to start relaying characters
	 * @param len  Number of characters to relay
	 */
	public @Override void write(char[] cbuf, int off, int len) {
		// Make a string starting at *off* that's *len* long.
		// Then relay it as usual.
		String substring = new String(cbuf, off, len);
		relay(substring);
	}

	/**
	 * Flushes all receiving streams.
	 * 
	 * Receiving callbacks are not affected by this operation (unless they
	 * are tied to a receiving stream, which is outside the scope of this
	 * containing class.)
	 */
	public @Override void flush() {
		for (PrintStream stream : receivingStreams) {
			stream.flush();
		}
	}
	
	/**
	 * Closes all receiving streams.
	 * 
	 * Receiving callbacks are not affected by this operation (unless they
	 * are tied to a receiving stream, which is outside the scope of this
	 * containing class.)
	 *
	 * This relay will still attempt to relay messages to its receiving
	 * streams even after they're closed, which will most likely result
	 * in an {@link java.io.IOException} being thrown.
	 */
	public @Override void close() {
		for (PrintStream stream : receivingStreams) {
			stream.close();
		}
	}
}
