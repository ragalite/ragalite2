b 6: Ant and Unix Scripting $ cat lab_readme.txt|


This CSE 15L lab has only one component: the lab exercise!  For the lab
exercise, you’ll be working in a team of two: pair programming, two people to
one machine.

You just need to login as ONE of you, using your cs15xxx user name.

Switch drivers (student on the keyboard) every 20 minutes.

Goals of Completing this Lab: Getting familiar with Apache Ant, and
experiencing examples where using it for automation and running of java
applications can be useful.

Learn features of bash scripting that can be used to create fun basic programs,
and can even help with your class scripting projects!  Section A: Ant Build
Tool Section A of this lab will give you some hands-on training with the Ant
Build Tool.

Apache Ant is a Java library and command-line tool whose purpose is to drive
processes that are described in build files as targets, as well as extension
points that are dependent upon each other.

Ant is mainly used to build and test Java applications.

Ant supplies a number of built-in tasks that help compile, assemble, test, and
run Java applications.

Ant can also be used effectively to build non Java applications, such as C or
C++ applications.


More generally, Ant can be used to pilot any type of process which can be
described in terms of targets and tasks.

Ant is written in Java.



Finally Apache Ant is a software tool for automating software build processes.


It is similar to Make but is implemented using the Java language, requires the
Java platform, and is best suited to building Java projects.

The most immediately noticeable difference between Ant and Make is that Ant
uses XML to describe the build process and its dependencies, whereas Make uses
Makefile format.

By default the XML file is named build.xml.



http://en.wikipedia.org/wiki/Apache_Ant

Setup: For section A, we will use the java files of Tetris Project:

$ mkdir Lab6 $ cd Lab6 $ mkdir sectionA $ cd sectionA $ cp -r
~/../public/Lab6/Tetris ./Tetris Now open, Eclipse from the terminal (eclipse
&).

It may take some time to open.

When it does open, you might see a gray window.

Eclipse is setting up and loading, so please be patient.

You will also have to close a number of popups before getting started (MAKE
SURE YOU CLOSE THEM BY CLICKING CANCEL, NOT ANY OTHER OPTION).

Once it opens, make sure you are currently in the Java perspective: (Windows =>
Open Perspective => Other => Java)

File => New => Project => Java => Java Project

Define the project name "Lab6AntProject" and then click Finish

Click "Yes" if you are asked to open Java Perspective.

Make sure you close the Welcome page to reveal the project directory!

Drag all Java files from ~/Lab6/sectionA/Tetris/src folder to src folder under
Project "Lab6AntProject".

To do so, you can go to the desktop file which should contain a folder named
cs15x??'s Home or home, which will contain the Lab6 folder you created earlier.

You can then navigate to Tetris/src and drag all the files to the
Lab6AntProject folder on the left of the Eclipse work page.


Select "Copy files" when prompted.



Right click on Main.java => Run as => Java Application; ensure that the game
opens without errors

Right click on project name “Lab6AntProject” => New => Other => Type ‘xml’
=>Select “XML File” and click Next File Name: build.xml, and then click Finish.



In build.xml file, you can define 'tasks' that you want to automate.

One task could depend on another task.

A short tutorial on Ant is available at http://ant.apache.org/manual/index.html

Take a look at the sample build.xml on http://en.wikipedia.org/wiki/Apache_Ant.


You will write a similar build.xml file.

Note how first the project name is defined, followed by several Ant tasks that
start with keyword target

Working with build.xml Step 0: Change to the Source tab on the bottom of the
build.xml window page in Eclipse.

Notice that Eclipse provides an XML declaration line for you.

The XML declaration is a processing instruction that identifies the document as
being XML.

All XML documents should begin with an XML declaration:

<?xml version="1.0" encoding="UTF-8"?> Step 1: Define your project name in
build.xml

The second line in this xml file defines the project name and default task to
be executed if no task is defined.

In your build.xml, define your project using:

<project name="Lab6AntProject" default="jar" basedir="."> Default task is 'jar'
which you will define later.

The base directory is defined as the current directory where build.xml resides.



Step 2: Define variables for directory names, and project names:

<property name="src.dir" location="src" /> 
<property name="build.dir" location="build" /> 
<property name="project.name" value="Lab6AntProject" />

Question 1: Using the above examples, how would you define a new variable that
stores the location of the directory "public"?  You can obtain the value of a
variable by using $ sign.

For example: ${build.dir} gives the build directory.


You will be using these variable names instead of using directory names
directly.



Step 3: Define "clean" task: This task deletes the build directory.

Fill in the blank and use the code below for your build.xml clean task.



<target name="clean"> <delete dir="______________" /> </target> Step 4: Define
"makedir" task: This task creates three directories: build, build/jars and
build/classes under the current directory defined by basedir variable (when you
defined the project name).

Fill in the blank and use the code below:

<target name="makedir"> <mkdir dir="______________" /> <mkdir
dir="______________" /> <mkdir dir="______________" /> </target> Step 5: Define
"compile" task: This task depends on clean and makedir tasks.

This task compiles all the java files in source folder and copies the .class
files into 'classes' directory that was made during the 'makedir' task.

Fill in the blank and use the code below:

<target name="compile" depends="______________,______________"> <javac
srcdir="______________" destdir="______________" compiler="javac1.7"/>
</target> Question 2: What does srcdir stand for? How about destdir?  Step 6:
Define the "jar" task.

The Java™ Archive (JAR) file format enables you to bundle multiple files into a
single archive file.

Typically a JAR file contains the class files and auxiliary resources
associated with applets and applications
(http://docs.oracle.com/javase/tutorial/deployment/jar/).



This task depends on 'compile' task.

The destination jar files should be stored in folder 'jars' under build
directory.

The filename should be build/jars/Lab6AntProject.jar (since it is the complete
path to the file we want to create.

In this task, you will bundle all class files into a single jar file (named
after your project).

Fill in the blank and use the code below:

<target name="jar" depends="______________"> <jar destfile="______________"
basedir="______________" /> </target> The last line of your build.xml in this
case should mark end of current project:

</project> Step 7: Once your build.xml is ready.

Right click on it in the Project Explorer and click Run As->Ant Build.

make sure you saved your changes first (Under File make sure to click SAVE
ALL).

The default task "jar" will run due to the default field in the project
definition.

It will trigger the tasks that it depends on, since this is the first run.

You should get a message "Build Successful" (some warnings may appear, but as
long as the build is successful, it's okay).

Checkout the 'classes' folder and the jar file to ensure that all tasks were
completed.

Note: You may not see these folders in Eclipse.

You can see the full path in the console output of Eclipse.

Follow this path in the terminal to verify the build worked correctly.

Find out how you can run individual tasks: clean, makedir, compile?

Question 3: How would you delete a directory with the property name "extras"?
Section B: Unix Scripting First of all, make sure you exit from the directory
sectionA and create a new directory in Lab6 called sectionB.

You can then change into the directory and proceed with your great work!

Getting Started Unix scripts give us an easy way to automate writing a lot of
commands into the terminal.

Today we will learn the building blocks of Unix scripts.

Scripts are very useful and are paramount to being efficient on the command
line.

Let's see how we can make a shell script by opening the command line and
typing:

vim hello.sh Go ahead and type this into hello.sh

#!/bin/bash str="Hello World!" echo $str Let's examine line 1 of the script.


Scripts in bash must start with this line of code.

It indicates which interpeter is required to run what we have written below.

In this case, we are using bash as our interpreter.



While simple, this script introduces variables.

Line 2 creates the variable str and assigns it the value "Hello World!".

To grab the value of a unix variable we must use a "$".

Without this, we cannot grab the value of the variable.

You can save and exit your script.

To run it we must change permissions to see that we do not have execute
permissions.

To fix this type the commands below.

The second line is how we can run our shell scripts.



chmod u+x hello.sh ./hello.sh You should see the contents of str printed to the
terminal.

If you do not see this, go ahead and read the steps above again to make sure
you followed all the directions.

Next we'll move on to loops!

Loops Loops are essential for scaling our scripts to work on a large set of
numbers, files, or to repeat a task many times.

Type the following in a new shell script called loops.sh.

It is important to note that you should only use ".." (2 periods only).



#!/bin/bash for i in {1..100}; do echo $i; done Again, save and quit out of
this script and write the following into the command line.



chmod u+x loops.sh ./loops.sh As expected, we see the numbers 1 through 100
printed.

Change the script with the code below to see how while loops are used.



#!/bin/bash i=0 while [ $i -lt 10 ] do echo $i; i=$((i+1)) done Now we will
break down the loop.

The second line is how we can assign a value to a variable.

Notice, there is no space between 'i' and '0'.

There are a couple things to notice about the loop syntax.



"-lt" is a binary operator that evaluates to true if the left hand argument is
less than the right side.

Comparison operators are used in boolean expressions.


The following table is a short explanation of some more expressions: | Example
| Result                                               | | --------------- |
---------------------------------------------------- | | expr1 -eq expr2 |
Returns true if the expressions are equal            | | expr1 -ne expr2 |
Returns true if the expressions are not equal        | | expr1 -gt expr2 |
Returns true if expr1 is greater than expr2          | | expr1 -ge expr2 |
Returns true if expr1 is greater than or equal to    | | expr1 -lt expr2 |
Returns true if expr1 is less than expr2             | | expr1 -le expr2 |
Returns true if expr1 is less than or equal to expr2 | | ! expr1         |
Negates the result of the expression                 | Each bracket must have a
space to the left and right of it.



Line 6 is one of the many ways to increment a variable in bash.



If/Else Let's see how we can use If/Else statements to make our scripts even
more powerful.

Below we have the skeleton for an if/else and it is your job to add it to your
loops.sh file.

Modify the if/else to print foo if the number is less than 5, and bar if the
number is greater than or equal to 5.

There are easier ways to do this without an if/else, but a simple example is
easy to learn from.

Note: Make sure when you are copying this script, you use a tab to indent
instead of spaces.



if [ condition ]; then whatever you want else whatever you want    fi Here are
some things to note:

The condition follows a similar format to that of the while loop

Inside each conditon use echo to print foo or bar

fi is used to indicate the end of a block

Go ahead and add modify loops.sh to print foo for all even numbers, and bar for
all odd numbers in the loop

Hint: $(( $i % 2 )) -eq 0 will be helpful for the condition

Switch/Case Statements The switch statement is another powerful programming
construct that can be used as a tool in bash.

These work by looking through some number of different values a variable can
hold and responding to these cases.

Create a new script called farm.sh and enter the following into this file:

#!/bin/bash

echo -n "Enter an animal: " read animal

case $animal in "dog") echo "woof";; "cat") echo "meow";; *) echo $animal " is
not on the farm";; esac Here are some things to note:

Lines 2 and 3 are prompting the user for input and reading the input.

Line 6 is where our switch starts.

Line 7 and 8 are possible values for the variable animal.

Line 9 is a default, and will catch anything that does not match the cases
above it.

Line 10 ends the case statement we started on line 6.

Take note of the ";;" (double semicolons) after each case statement.

Your task is to add three more animals to the case statement.

Once you complete this task, put the switch statement in a loop so it runs
forever.

This means you can input an animal and your program will output the appropriate
response, and prompt the user for another input.

Once this is complete move on to the next section.



Goal: Learn about Unix Functions Bash Functions As in almost any programming
language, you can use functions to group pieces of code in a more logical way
or practice the divine art of recursion.



Declaring a function is just a matter of writing function my_func { my_code }.



Calling a function is just like calling another program, you just write its
name.



Open hello.sh in vim and remove the existing code and let's learn about
functions!!!

Functions #!/bin/bash function hello { echo Hello } hello On line 5, the
function hello is run.

You can verify this by running the script.



Functions with Parameters #!/bin/bash function hello { echo Hello!  }

function helloWithParam { echo "Hello" $1 }  

hello helloWithParam student This script is almost identically to the previous
one.

The main difference is the Arguments, within functions, are treated in the same
manner as arguments given to the script.



Goal: Practice Unix Scripting Challenge 1 Using what you learned about Unix
scripting, you will write your own bash script

The program you will write will read in a person's age and name and then print
out if the person can vote.



Use the following as an example.

Hint: you can use $1 for the first argument passed in by the user.



$ ./canVote Lubomir 21 Hello Lubomir, you can vote!

$ ./canVote Jim 7 Hello Jim, you cannot vote yet.

Challenge 2 Now update the program to use read.

Use the following as an example

$ ./canVote Name: Lubomir Age: 21 Hello Lubomir, you can vote!

$ ./canVote Name: Jim Age: 7 Hello Jim, you cannot vote yet.

Challenge 3 Create a new bash script called funWithLoops.sh This program will
read in 2 positive numbers and print out all the numbers between them.

You need to handle a few errors.

Keep in mind:

Both numbers are positive The numbers are unique The first number is less than
the second The loop is inclusive $ ./funWithLoops 1 5 1 2 3 4 5

$ ./funWithLoops 5 3 Error: please make sure the first number is smaller than
the second Please complete all three challenges before moving on.



Goal: Unix Commands top, ping, traceroute, uptime, sleep In this section we
will be learning the unix commands top, ping, traceroute, uptime, sleep

top The top command is used to see what processes are running on a server or
machine.

It can be run from the terminal by typing:

$ top You will see various system usage information.

You will also see who is running what tasks and how many resources they are
using.

Additionally, at the top you will see total system usage.

Top is invaluable for system management and has many options to let you access
a lot of data quickly.

You can type man top to see how you can sort by memory, cpu, time, and many
other fields.



ping The ping command is used to check if a host (or website) is up.



$ ping facebook.com You are now pinging facebook and it is up (hopefully).

You should see "64 bytes from...." meaning that facebook is sending back data.

Go ahead and try this on different websites, and try one that is not a website
to see what the error message is.

You can stop pinging a server with control + C

As usual, man ping will give you more information about this command.



traceroute traceroute is used to see what each packet passes through on its
final destination.

It will trace the route for you (get it).



$ traceroute yahoo.com This is useful to see where your packets are going and
for potential debugging of networked systems.

Additionally, it gives you information about each step of the way including
that gateway's ip address, and the time spent at that gateway.

As usual, more information about traceroute can be found by typing man
traceroute.



uptime The uptime command is used to give you various usage statistics.

This can be useful in cases where ieng6 is very slow and you now have a tool to
pinpoint the problem.

Ideally, uptime should report numbers that are relatively low, (normally less
than 3).



$ uptime You should see the current time, how long the system has been up, the
number of users, and the load average of the system over the last 1, 5, and 15
minutes.

You may notice that this information is available through top as well.



sleep sleep is a very simply command, but very useful for shell scripts.

The purpose of the sleep command is to do nothing! You can call using the line
below, replacing seconds with some number.

Use a small number so you don't waste too much time.



$ sleep [seconds] Often times your shell script will need some delay or you may
need to wait for some task to happen.

Another use case is perhaps you perform some task, like mail, in a loop, but
sending a few hundred emails simultaneously will overwhelm your system.

You could sleep for 1 second after every 50 iterations and ensure your system
does not have to send too many emails at any given time.

For example, you can open up loops.sh in vim and add the sleep command per
iteration of the loop (but use a small number) and see the magic unfold!

Goal: Learn even more Unix Commands If you are finished with the lab, please
follow this link.

Do as much of it as you can in the remaining lab time.



Question 4: What is the use of these special symbols in regular expression: ^,
$, .

and *?  Question 5: How do you make sed delete the first line of a file and
print the rest of the file?  Question 6: Write a UNIX command using cat and sed
that finds all the lines starting with "alpha" and then deletes them.


Question 7: Write what this regular expression matches: /[tT]he/ Question 8:
Write what this regular expression matches: /^$/ You are now done with this
lab!

Checkoff Criteria Show your completed challenges Show your README with the
completed 8 questions
